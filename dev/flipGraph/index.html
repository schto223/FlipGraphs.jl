<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modular Flip Graphs of Closed Orientable Surfaces · FlipGraphs.jl</title><meta name="title" content="Modular Flip Graphs of Closed Orientable Surfaces · FlipGraphs.jl"/><meta property="og:title" content="Modular Flip Graphs of Closed Orientable Surfaces · FlipGraphs.jl"/><meta property="twitter:title" content="Modular Flip Graphs of Closed Orientable Surfaces · FlipGraphs.jl"/><meta name="description" content="Documentation for FlipGraphs.jl."/><meta property="og:description" content="Documentation for FlipGraphs.jl."/><meta property="twitter:description" content="Documentation for FlipGraphs.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FlipGraphs.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../">FlipGraphs.jl Documentation</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../quickStart/">Quick Start</a></li></ul></li><li><span class="tocitem">Convex Polygons</span><ul><li><a class="tocitem" href="../polygonTriangulation/">Triangulations of Convex Polygons</a></li><li><a class="tocitem" href="../flipGraphPlanar/">Flip Graphs of Convex Polygons</a></li></ul></li><li><span class="tocitem">Closed Surfaces</span><ul><li><a class="tocitem" href="../deltaComplex/">Triangulations of Closed Surfaces</a></li><li class="is-active"><a class="tocitem" href>Modular Flip Graphs of Closed Orientable Surfaces</a><ul class="internal"><li><a class="tocitem" href="#Structures"><span>Structures</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Graph-methods"><span>Graph methods</span></a></li><li><a class="tocitem" href="#Comparing-Triangulations"><span>Comparing Triangulations</span></a></li><li><a class="tocitem" href="#Canonical-labeling-of-DeltaComplexes"><span>Canonical labeling of <code>DeltaComplex</code>es</span></a></li></ul></li></ul></li><li><span class="tocitem">General Utilities</span><ul><li><a class="tocitem" href="../generalUtilities/">General utilities</a></li><li><a class="tocitem" href="../exporting/">Exporting</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Closed Surfaces</a></li><li class="is-active"><a href>Modular Flip Graphs of Closed Orientable Surfaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modular Flip Graphs of Closed Orientable Surfaces</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/schto223/FlipGraphs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/schto223/FlipGraphs.jl/blob/main/docs/src/flipGraph.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Modular-Flip-Graphs-of-Closed-Orientable-Surfaces"><a class="docs-heading-anchor" href="#Modular-Flip-Graphs-of-Closed-Orientable-Surfaces">Modular Flip Graphs of Closed Orientable Surfaces</a><a id="Modular-Flip-Graphs-of-Closed-Orientable-Surfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Modular-Flip-Graphs-of-Closed-Orientable-Surfaces" title="Permalink"></a></h1><p>Contrary to flip graphs of planar triangulations like that of a convex polygon, the flip graph of a closed surface is generally infinitely large. Therefore, it is impossible to construct the whole flip graph. Not only are they infinitely large, but they also &quot;grow&quot; very fast. For this reason, it is more interesting and achievable to look at the <strong>modular flip graphs</strong>. These are graphs whose vertices are homotopy classes of triangulations on closed surfaces.</p><p>It turns out that the vertices of modular flip graphs are equivalent to the <em>Δ-coplexes</em> which we have already modeled in <a href="../deltaComplex/#FlipGraphs.DeltaComplex">DeltaComplex</a>.</p><h2 id="Structures"><a class="docs-heading-anchor" href="#Structures">Structures</a><a id="Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Structures" title="Permalink"></a></h2><p>A <strong><code>FlipGraph</code></strong> consists of vertices that represent homotopy classes of <code>DeltaComplex</code>es and edges between them.  In order to be able to efficiently compute the whole flip graph, vertices are not <code>DeltaComplex</code>es but have their own structure (<code>FGVertex</code>) which consists of a <code>DeltaComplex</code> with additional information.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlipGraphs.FlipGraph" href="#FlipGraphs.FlipGraph"><code>FlipGraphs.FlipGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FlipGraph &lt;: AbstractGraph{Int}</code></pre><p>A <em>graph</em> representing the <strong>flip graph</strong> of a <strong>Δ-Complex</strong>.</p><p>Vertices are isotopy classes of triangulations of the same surface.<br/>Two vertices are linked by an edge, if the respective triangulations differ only by a single flip.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L133-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlipGraphs.FGVertex" href="#FlipGraphs.FGVertex"><code>FlipGraphs.FGVertex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FGVertex</code></pre><p>A <em>vertex</em> in a <code>FlipGraph</code>. </p><p>A <code>FGVertex</code> is composed of a representant (<code>DeltaComplex</code>) of the isotopy class of that vertex.  The representant has been relabeled with one of the canonical labeling obtained by an adaptation of <em>McKay&#39;s Algorithm</em>. Additionally, the <code>FGVertex</code> contains the number of labeling that are output by the respective <em>McKay&#39;s Algorithms</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L33-L41">source</a></section></article><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><p>Currently, it is only possible to create the modular flip graph of a closed <em>orientable</em> surface. Non-orientable surfaces would need an adapted approach to solving, as the way they are modeled right now would require a lot more options to be checked just to determine if two <code>DeltaComplex</code>es are isomorphic to each other.</p><p>As even modular flip graphs become very large quite quickly, you have the possibility of only building a local portion of a flip graph. The way this works is, by giving it a <code>DeltaComplex</code>, which forms the root vertex, and setting the <code>depth</code>, which will limit the vertices to only include those that are at a distance less or equal to this <code>depth</code> from the root.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlipGraphs.flipgraph_modular" href="#FlipGraphs.flipgraph_modular"><code>FlipGraphs.flipgraph_modular</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flipgraph_modular(g::Integer, p::Integer; kwargs..) :: FlipGraph</code></pre><p>Construct the <strong>modular flip graph</strong> for a genus <code>g</code> closed orientable surface with <code>p</code> points on it.  </p><p><strong>Arguments</strong></p><ul><li><code>labeled_points :: Bool = true</code> : If set to <code>false</code>, the isomorphism also includes a renaming of the points. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L286-L293">source</a></section><section><div><pre><code class="language-julia hljs">flipgraph_modular(D::DeltaComplex; kwargs..)</code></pre><p>Construct the <strong>modular flip graph</strong> for the closed orientable surface defined by the <em>Δ-complex</em> <code>D</code>.  </p><p><strong>Arguments</strong></p><ul><li><code>labeled_points :: Bool = true</code> : If is set to <code>false</code>, then the isomorphism also includes a renaming of the points. </li><li><code>depth :: Integer = ∞</code> : Determines the depth to which the flip grap should be constructed. i.e. up to which distance from <code>D</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L298-L306">source</a></section></article><h2 id="Graph-methods"><a class="docs-heading-anchor" href="#Graph-methods">Graph methods</a><a id="Graph-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-methods" title="Permalink"></a></h2><p>As with <a href="../flipGraphPlanar/#FlipGraphs.FlipGraphPlanar"><code>FlipGraphPlanar</code></a>, there are a bunch of methods which overload some of the main functions from the <a href="https://juliagraphs.org/Graphs.jl/stable/">Graphs.jl</a> package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.nv-Tuple{FlipGraph}" href="#Graphs.nv-Tuple{FlipGraph}"><code>Graphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nv(G::FlipGraph) :: Int</code></pre><p>Return the number of vertices in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.ne-Tuple{FlipGraph}" href="#Graphs.ne-Tuple{FlipGraph}"><code>Graphs.ne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ne(G::FlipGraph) :: Int</code></pre><p>Return the number of edges in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.vertices-Tuple{FlipGraph}" href="#Graphs.vertices-Tuple{FlipGraph}"><code>Graphs.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(G::FlipGraph) :: Vector{FGVertex}</code></pre><p>Return the list of all the vertices that have been constructed in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L217-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlipGraphs.vertices_deltacomplex" href="#FlipGraphs.vertices_deltacomplex"><code>FlipGraphs.vertices_deltacomplex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vertices_deltacomplex(G::FlipGraph) :: Vector{DeltaComplex}</code></pre><p>Construct a list of all the <code>DeltaComplex</code>s which form the vertices in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L231-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.edges-Tuple{FlipGraph}" href="#Graphs.edges-Tuple{FlipGraph}"><code>Graphs.edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edges(G::FlipGraph) :: Vector{Edge}</code></pre><p>Construct a list containing all the edges in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.has_vertex-Tuple{FlipGraph, Integer}" href="#Graphs.has_vertex-Tuple{FlipGraph, Integer}"><code>Graphs.has_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_vertex(G::FlipGraph, v::Integer) :: Bool</code></pre><p>Return true if <code>v</code> is a valid index of a vertex in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlipGraphs.get_vertex-Tuple{FlipGraph, Integer}" href="#FlipGraphs.get_vertex-Tuple{FlipGraph, Integer}"><code>FlipGraphs.get_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_vertex(G::FlipGraph, id::Integer) :: Vector{FGVertex}</code></pre><p>Return the <code>id</code>-th vertex the flip graph <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L224-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.has_edge-Tuple{FlipGraph, Graphs.SimpleGraphs.SimpleEdge}" href="#Graphs.has_edge-Tuple{FlipGraph, Graphs.SimpleGraphs.SimpleEdge}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(G::FlipGraph, e::Edge) :: Bool</code></pre><p>Return <code>true</code> if <code>e</code> is an edge in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.has_edge-Tuple{FlipGraph, Integer, Integer}" href="#Graphs.has_edge-Tuple{FlipGraph, Integer, Integer}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(G::FlipGraph, s::Integer, d::Integer) :: Bool</code></pre><p>Return <code>true</code> if there is an edge between the <code>s</code>-th and <code>d</code>-th vertex in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.has_edge-Tuple{FlipGraph, FGVertex, FGVertex}" href="#Graphs.has_edge-Tuple{FlipGraph, FGVertex, FGVertex}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(G::FlipGraph, v1::FGVertex, v2::FGVertex) :: Bool</code></pre><p>Return <code>true</code> if there is an edge between <code>v1</code> and <code>v2</code> in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.neighbors-Tuple{FlipGraph, Integer}" href="#Graphs.neighbors-Tuple{FlipGraph, Integer}"><code>Graphs.neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbors(G::FlipGraph, v::Integer) :: Vector{Int32}</code></pre><p>Return a list of the indices of all the neighboring vertices of the <code>v</code>-th vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlipGraphs.diameter-Tuple{FlipGraph}" href="#FlipGraphs.diameter-Tuple{FlipGraph}"><code>FlipGraphs.diameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diameter(G::FlipGraph)</code></pre><p>Compute the diameter of the <code>FlipGraph</code> <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L520-L524">source</a></section></article><h2 id="Comparing-Triangulations"><a class="docs-heading-anchor" href="#Comparing-Triangulations">Comparing Triangulations</a><a id="Comparing-Triangulations-1"></a><a class="docs-heading-anchor-permalink" href="#Comparing-Triangulations" title="Permalink"></a></h2><p>One problem in deciding if two triangulations are equivalent, is that the naming of the vertices, edges and points is completely arbitrary. In the act of flipping, <code>DualEdge</code>s and <code>TriFace</code>s &quot;move around&quot;. It is therefore possible to obtain two <code>DeltaComplex</code>es representing the same triangulation of a surface but with different labeled <code>TriFace</code>s and <code>DualEdge</code>s. </p><p>The following method will determine if two <code>DeltaComplex</code>es are isomorphic to each other and therefore represent the same vertex in the modular flip graph:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlipGraphs.is_isomorphic-Tuple{DeltaComplex, DeltaComplex}" href="#FlipGraphs.is_isomorphic-Tuple{DeltaComplex, DeltaComplex}"><code>FlipGraphs.is_isomorphic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_isomorphic(D1::DeltaComplex, D2::DeltaComplex; kwargs..) :: Bool</code></pre><p>Return <code>true</code> if <code>D1</code> is isomorph to <code>D2</code> up to a renaming of the vertices, edges and if <code>labeled_points=false</code> also points.</p><p><strong>Arguments</strong></p><ul><li><code>labeled_points :: Bool = true</code> : If labeled_points is set to <code>false</code>, then the isomorphism also includes a renaming of the points. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L394-L401">source</a></section></article><h2 id="Canonical-labeling-of-DeltaComplexes"><a class="docs-heading-anchor" href="#Canonical-labeling-of-DeltaComplexes">Canonical labeling of <code>DeltaComplex</code>es</a><a id="Canonical-labeling-of-DeltaComplexes-1"></a><a class="docs-heading-anchor-permalink" href="#Canonical-labeling-of-DeltaComplexes" title="Permalink"></a></h2><p>Checking every possible permutation of <code>TriFace</code> and <code>DualEdge</code> labeling was not an option, as the number of possibilities would blow up immediately. </p><p>What one can do instead is try to find a canonical labeling. This module uses a version of <em>McKay&#39;s canonical graph labeling algorithm</em><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> to try and determine a unique labeling based on the relationship of vertices and edges to other vertices and edges. In general, it is not always possible to determine a unique labeling. However, with this method, we can reduce the number of labelings to a manageable number.</p><p>The <code>mcKay</code> methods each return a permutation vector <code>p</code> which can be interpreted as a Cauchy&#39;s one-line notation for permutations.  For example, <code>p = [3,5,1,2,6,4]</code> would correspond to the following permutation:</p><p class="math-container">\[σ = \begin{pmatrix}
1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6\\
3 &amp; 5 &amp; 1 &amp; 2 &amp; 6 &amp; 4
\end{pmatrix} = (1\ 3)(2\ 5\ 6\ 4)\]</p><p>This algorithm has been adapted to find canonical labelings for points, vertices and edges. These are not independent from each other. In fact, only the point labelings depend on themselves. mcKay<em>vertices will give different results basedon the point labelings, and mcKay</em>edges will give different results based on both point and vertex labelings. Therefore, they are to be used in sequence.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlipGraphs.mcKay_points" href="#FlipGraphs.mcKay_points"><code>FlipGraphs.mcKay_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mcKay_points(D::DeltaComplex; kwargs..) :: Vector{Vector{Int32}}</code></pre><p>Apply a version of McKay&#39;s canonical graph labeling algorithm to determine all possible permutations  of the points which give a canonical isomorphism class representant.</p><p>Return a vector of permutation vectors <code>p</code> such that point 1 becomes point <code>p[1]</code>, point 2 becomes point <code>p[2]</code>,...</p><p><strong>Arguments</strong></p><ul><li><code>only_one :: Bool = false</code>, If set to true, the algorithm will stop after finding a single valid permutation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L643-L653">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlipGraphs.mcKay_vertices" href="#FlipGraphs.mcKay_vertices"><code>FlipGraphs.mcKay_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mcKay_vertices(D::DeltaComplex; , A_deltacomplex::Matrix{&lt;:Integer}, point_perm::Vector{&lt;:Integer}) :: Vector{Vector{Int32}}</code></pre><p>Apply a version of McKay&#39;s canonical graph labeling algorithm in order to determine all possible permutations  of the <code>TriFace</code>s which give a canonical isomorphism class representant.</p><p>Return a vector of permutation vectors <code>p</code> such that <code>TriFace</code> 1 becomes <code>TriFace</code> <code>p[1]</code>, <code>TriFace</code> 2 becomes <code>TriFace</code> <code>p[2]</code>, ...<br/>If <code>only_one=true</code>, the algorithm stops after finding one valid permutation.</p><p>The vectors <code>point_perm</code> determins how the points of <code>D</code> are implied to have been renamed, without actually having been changed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L682-L692">source</a></section><section><div><pre><code class="language-julia hljs">mcKay_vertices(D::DeltaComplex; kwargs..) :: Vector{Vector{Int32}}</code></pre><p>Apply a version of McKay&#39;s canonical graph labeling algorithm in order to determine all possible permutations  of the <code>TriFace</code>s which give a canonical isomorphism class representant.</p><p>Return a vector of permutation vectors <code>p</code> such that <code>TriFace</code> 1 becomes <code>TriFace</code> <code>p[1]</code>, <code>TriFace</code> 2 becomes <code>TriFace</code> <code>p[2]</code>, ...<br/>If <code>only_one=true</code>, the algorithm stops after finding one valid permutation.</p><p><strong>Arguments</strong></p><ul><li><code>only_one :: Bool = false</code>, If set to true, the algorithm will stop after finding a single valid permutation.</li><li>A_deltacomplex :: Matrix{&lt;:Integer} = Matrix{Int32}(multi<em>adjacency</em>matrix_deltacomplex(D)). If provided, the algorithm will use the adjacency matrix of the <code>DeltaComplex</code> <code>D</code>. If not, the algorithm would have to compute it itself.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L714-L726">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlipGraphs.mcKay_edges" href="#FlipGraphs.mcKay_edges"><code>FlipGraphs.mcKay_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mcKay_edges(D::DeltaComplex; kwargs..) :: Vector{Vector{Int32}}</code></pre><p>Apply McKay&#39;s canonical graph labeling algorithm in order to determine all possible permutations  of the <code>DualEdge</code>s which give a canonical isomorphism class representant.</p><p>Return a vector of permutation vectors <code>p</code> such that <code>DualEdge</code> 1 becomes <code>DualEdge</code> <code>p[1]</code>, <code>DualEdge</code> 2 becomes <code>DualEdge</code> <code>p[2]</code>, ...<br/></p><p><strong>Arguments</strong></p><ul><li><code>only_one :: Bool = false</code>, If set to true, the algorithm will stop after finding a single valid permutation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/FlipGraphs.jl/blob/c1db7d25939f260b52a68d79dc3dc7148a378d21/src/flipGraph.jl#L763-L773">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Hartke, S.G., &amp; Radcliffe, A.J. (2008). McKay ’ s Canonical Graph Labeling Algorithm.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../deltaComplex/">« Triangulations of Closed Surfaces</a><a class="docs-footer-nextpage" href="../generalUtilities/">General utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 18 June 2024 14:17">Tuesday 18 June 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
