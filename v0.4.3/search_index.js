var documenterSearchIndex = {"docs":
[{"location":"internal/","page":"-","title":"-","text":"These are some functions, which are in general not usefull to a person using the package:","category":"page"},{"location":"internal/","page":"-","title":"-","text":"    FGVertexCandidate\n\n    is_isomorphic(::FGVertexCandidate, ::FGVertex)\n    rename_vertices!\n    diameter(::FGVertex)","category":"page"},{"location":"internal/#FlipGraphs.FGVertexCandidate","page":"-","title":"FlipGraphs.FGVertexCandidate","text":"struct FGVertexCandidate\n\nA candidate for a possible vertex in a flip graph. \n\nIt hasn't yet been decided if this candidate is a new vertex in the graph, or isomorph to an already existing DeltaComplex.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FlipGraphs.is_isomorphic-Tuple{FGVertexCandidate, FGVertex}","page":"-","title":"FlipGraphs.is_isomorphic","text":"is_isomorphic(candidate::FGVertexCandidate, fgv::FGVertex; kwargs...) -> Bool\n\nReturn true if candidate is in the isotopy class of fgv. \n\nArguments\n\nlabeled_points :: Bool = true : If is set to false, then the isomorphism would also allow a relabeling of the points. \n\n\n\n\n\n","category":"method"},{"location":"internal/#FlipGraphs.rename_vertices!","page":"-","title":"FlipGraphs.rename_vertices!","text":"rename_vertices!(g::TriangulatedPolygon, p::Vector{<:Integer}) :: TriangulatedPolygon\n\nRename the vertices of the triangulated convex polygon g by applying the permutation p.\n\n\n\n\n\nrename_vertices!(D::DeltaComplex, p::Vector{<:Integer})\n\nRelabel every vertex(TriFace) in D, according to the permutation p.\n\nTriFace 1 => TriFace p1 \n\n\n\n\n\n","category":"function"},{"location":"internal/#FlipGraphs.diameter-Tuple{FGVertex}","page":"-","title":"FlipGraphs.diameter","text":"diameter(v::FGVertex)\n\nCompute the diameter of the DeltaComplex that represents the FlipGraphVertex v.\n\n\n\n\n\n","category":"method"},{"location":"quickStart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"DocTestSetup = quote\n    using FlipGraphs\nend","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"If you're already familiar with the concept of flip graphs, triangulations on closed surfaces, and Δ-complexes, and don't want to read the whole documentation, then here are some quick examples of what you can do with this package.","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"In any other case, please be sure to have a look at the rest of the documentation first.","category":"page"},{"location":"quickStart/#Triangulated-Convex-Polygon","page":"Quick Start","title":"Triangulated Convex Polygon","text":"","category":"section"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Create a triangulated convex 10-gon:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> g = triangulated_polygon(8)\nTriangulatedPolygon with 8 vertices, and adjacency list:\n 1  → [2, 8]\n 2  → [1, 3, 8]\n 3  → [2, 4, 8, 7]\n 4  → [3, 5, 7, 6]\n 5  → [4, 6]\n 6  → [5, 7, 4]\n 7  → [6, 8, 3, 4]\n 8  → [7, 1, 2, 3]","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Check if the edge going from vertex 2 to vertex 10 can be flipped:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> is_flippable(g, 2, 8)\ntrue","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Flip the edge connecting vertices 2 and 10:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> flip!(g, 2, 8)\nTriangulatedPolygon with 8 vertices, and adjacency list:\n 1  → [2, 8, 3]\n 2  → [1, 3]\n 3  → [2, 4, 8, 7, 1]\n 4  → [3, 5, 7, 6]\n 5  → [4, 6]\n 6  → [5, 7, 4]\n 7  → [6, 8, 3, 4]\n 8  → [7, 1, 3]","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Construct the flip graph of a convex octagon:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> G = flipgraph_planar(8)\nFlipGraphPlanar with 132 vertices and 330 edges","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Export the generated flip graph as a .gml file:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> export_gml(\"C:/Users/USERNAME/Desktop/FILENAME.gml\", G);","category":"page"},{"location":"quickStart/#Δ-Complex-/-Triangulation-of-closed-surface","page":"Quick Start","title":"Δ-Complex / Triangulation of closed surface","text":"","category":"section"},{"location":"quickStart/#DeltaComplex","page":"Quick Start","title":"DeltaComplex","text":"","category":"section"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"A DeltaComplex is the dual of a triangulation on a closed surface. It can be used to compute things like the diameter, but it does not offer a unique model of a triangulation on a closed surface.  Every DeltaComplex can be interpreted as the homeomorphism class of triangulations of points on a closed surface.","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Create a DeltaComplex of a surface of genus 1 with 2 points:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> D = deltacomplex(1, 2)\nDeltaComplex on orientable surface of genus 1 with 2 points\n4 TriFaces:\n TriFace #1: Points(1 1 2) Neighbors(2 3 4)\n TriFace #2: Points(1 1 1) Neighbors(4 1 3)\n TriFace #3: Points(1 1 2) Neighbors(2 4 1)\n TriFace #4: Points(1 1 2) Neighbors(2 1 3)\n6 DualEdges:\n DualEdge 1 : (Δ3)-(1)-------(3)-(Δ2)\n DualEdge 2 : (Δ1)-(1)-------(2)-(Δ2)\n DualEdge 3 : (Δ2)-(1)-------(1)-(Δ4)\n DualEdge 4 : (Δ4)-(2)-------(3)-(Δ1)\n DualEdge 5 : (Δ1)-(2)-------(3)-(Δ3)\n DualEdge 6 : (Δ3)-(2)-------(3)-(Δ4)","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Check if the 4th edge (DualEdge 4) can be flipped:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> is_flippable(D, 4)\ntrue","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Flip said edge:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> flip!(D, 4)\nDeltaComplex on orientable surface of genus 1 with 2 points\n4 TriFaces:\n TriFace #1: Points(1 2 1) Neighbors(3 3 4)\n TriFace #2: Points(1 1 1) Neighbors(4 4 3)\n TriFace #3: Points(1 1 2) Neighbors(2 1 1)\n TriFace #4: Points(1 1 1) Neighbors(2 1 2)\n6 DualEdges:\n DualEdge 1 : (Δ3)-(1)-------(3)-(Δ2)\n DualEdge 2 : (Δ4)-(1)-------(2)-(Δ2)\n DualEdge 3 : (Δ2)-(1)-------(3)-(Δ4)\n DualEdge 4 : (Δ4)-(2)-------(3)-(Δ1)\n DualEdge 5 : (Δ1)-(1)-------(3)-(Δ3)\n DualEdge 6 : (Δ3)-(2)-------(2)-(Δ1)","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Randomly flip edges in D until the diameter stabilizes:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> randomize!(D)\n10300000\njulia> D\nDeltaComplex on orientable surface of genus 1 with 2 points\n4 TriFaces:\n TriFace #1: Points(1 1 1) Neighbors(3 2 2)\n TriFace #2: Points(1 1 1) Neighbors(1 3 1)\n TriFace #3: Points(1 1 1) Neighbors(1 2 4)\n TriFace #4: Points(2 1 1) Neighbors(4 3 4)\n6 DualEdges:\n DualEdge 1 : (Δ3)-(3)-------(2)-(Δ4)\n DualEdge 2 : (Δ3)-(2)-------(2)-(Δ2)\n DualEdge 3 : (Δ4)-(3)-------(1)-(Δ4)\n DualEdge 4 : (Δ1)-(2)-------(3)-(Δ2)\n DualEdge 5 : (Δ1)-(1)-------(1)-(Δ3)\n DualEdge 6 : (Δ2)-(1)-------(3)-(Δ1)","category":"page"},{"location":"quickStart/#Modular-FlipGraph","page":"Quick Start","title":"Modular FlipGraph","text":"","category":"section"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Construct the modular flip graph of a torus with 2 labeled points on it:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> G = flipgraph_modular(1,2)\nmodular FlipGraph with 9 vertices and 8 edges","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Construct the modular flip graph of a torus with 2 unlabeled points on it:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> G = flipgraph_modular(1,2;labeled_points=false)\nmodular FlipGraph with 5 vertices and 4 edges","category":"page"},{"location":"polygonTriangulation/#Triangulations-of-Convex-Polygons","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"In order to better understand triangulations, flips and flip graphs, it can be helpful to start simple. If you take any number of points and iteratively connect them with straight edges that do not cross each other  until you can no longer add an edge that does not cross any other edge, what you'll get is a (geometric) triangulation.","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"To get from one triangulation of a set of points to another, you may choose an inner edge and flip it.  If you look at any inner edge, the two triangles adjacent to it form a quadrilateral, with the edge as one of its diagonals. To flip an edge, all we have to do is replace it with the other diagonal.  As we don't want to have straight edges that cross each other, a flip can only be done if the quadrilateral is convex and no three of its corners lie on the same line. As we are interested in taking this theory to closed surfaces, where we will no longer have the restriction of edges being straight, we will only consider triangulations of points in convex general position. In this case, a triangulation in the geometric sense is equivalent to a triangulation of points on the border of a disc or a maximal outerplanar graph.","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"We do not care where exactly the points are located; however, in order to keep in line with the geometric sense and have a simple visualization, we will consider these points to be the vertices of a convex polygon (i.e. points in convex position). ","category":"page"},{"location":"polygonTriangulation/#Structures","page":"Triangulations of Convex Polygons","title":"Structures","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    TriangulatedPolygon","category":"page"},{"location":"polygonTriangulation/#FlipGraphs.TriangulatedPolygon","page":"Triangulations of Convex Polygons","title":"FlipGraphs.TriangulatedPolygon","text":"struct TriangulatedPolygon <: AbstractGraph{Int32}\n\nA structure representing a triangulation of a convex polygon.\n\n\n\n\n\n","category":"type"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"TriangulatedPolygon implements the AbstractGraph interface from Graphs.jl. It is therefore possible to use it with other packages that work with Graphs.jl.","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"Vertices are not explicitly stored in TriangulatedPolygon.  Only the total number of vertices is stored. They are implicitly labeled by the integers from 1 up to the total number of vertices.\nEdges are stored as an adjacency list.","category":"page"},{"location":"polygonTriangulation/#Constructors","page":"Triangulations of Convex Polygons","title":"Constructors","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    triangulated_polygon","category":"page"},{"location":"polygonTriangulation/#FlipGraphs.triangulated_polygon","page":"Triangulations of Convex Polygons","title":"FlipGraphs.triangulated_polygon","text":"triangulated_polygon(n::Integer) :: TriangulatedPolygon\n\nCreate a triangulated convex n-gon. \n\nVertices are named from 1 to n in an anticlockwise manner. The inside is triangulated in a zig-zag pattern.\n\n\n\n\n\n","category":"function"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"As an example, the output of triangulated_polygon(9) would be a graph that corresponds to the following triangulation of a 9-gon:","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"<!---![Triangulated 9-gon](assets/triPoly-9.png)-->\n<p align=\"center\">\n  <img src=\"assets/triPoly-9.png\" width=\"360px\" hspace=\"20\">\n</p>","category":"page"},{"location":"polygonTriangulation/#Graph-Methods","page":"Triangulations of Convex Polygons","title":"Graph Methods","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"The following methods overload some of the main functions from the Graphs.jl package.","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    nv(::TriangulatedPolygon)\n    ne(::TriangulatedPolygon)\n    vertices(::TriangulatedPolygon)    \n    has_vertex(::TriangulatedPolygon, v)\n\n    edges(::TriangulatedPolygon)\n    edges_inner(::TriangulatedPolygon)\n    edges_outer(::TriangulatedPolygon)\n    \n    has_edge(::TriangulatedPolygon, e::Edge)\n    has_edge(::TriangulatedPolygon, s, d)\n\n    is_inner(::TriangulatedPolygon, ::Edge)\n    is_outer(::TriangulatedPolygon, ::Edge)\n\n    neighbors(::TriangulatedPolygon, ::Integer)\n\n    is_identical(::TriangulatedPolygon, ::TriangulatedPolygon)\n\n    rotate!(::TriangulatedPolygon, ::Integer)\n    mirror!(::TriangulatedPolygon)","category":"page"},{"location":"polygonTriangulation/#Graphs.nv-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"Graphs.nv","text":"nv(g::TriangulatedPolygon) :: Int\n\nReturn the number of vertices/points in the triangulated convex polygon g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.ne-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"Graphs.ne","text":"ne(g::TriangulatedPolygon) :: Int\n\nReturn the number of edges in the triangulated convex polygon g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.vertices-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"Graphs.vertices","text":"vertices(g::TriangulatedPolygon) :: Vector{Int}\n\nCreate a list of all the vertices in the triangulated convex polygon g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.has_vertex-Tuple{TriangulatedPolygon, Any}","page":"Triangulations of Convex Polygons","title":"Graphs.has_vertex","text":"has_vertex(g::TriangulatedPolygon, v::Integer)\n\nReturn true if v is a vertex in g. \n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.edges-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"Graphs.edges","text":"edges(g::TriangulatedPolygon{T}) :: Vector{SimpleEdge{T}} where T<:Integer\n\nCompute and return a list of all the inner edges in g. \n\nEdges are not directed. It is, however, necessary for computations to define a source and a target.  For TriangulatedPolygon, the source will be the incident vertex with the smaller id.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.edges_inner-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.edges_inner","text":"edges_inner(g::TriangulatedPolygon{T}) :: Vector{SimpleEdge{T}} where T<:Integer\n\nCompute and return a list of all the edges in g. These are exactly the flippable edges in g.\n\nEdges are not directed. It is, however, necessary for computations to define a source and a target.  For TriangulatedPolygon, the source will be the incident vertex with the smaller id.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.edges_outer-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.edges_outer","text":"edges_outer(g::TriangulatedPolygon{T}) :: Vector{SimpleEdge{T}} where T<:Integer\n\nCompute and return a list of all the outer edges in g. These are exactly the non-flippable edges in g.\n\nEdges are not directed. It is, however, necessary for computations to define a source and a target.  For TriangulatedPolygon, the source will be the incident vertex with the smaller id.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.has_edge-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"Graphs.has_edge","text":"has_edge(g::TriangulatedPolygon, e::Edge)\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.has_edge-Tuple{TriangulatedPolygon, Any, Any}","page":"Triangulations of Convex Polygons","title":"Graphs.has_edge","text":"has_edge(g::TriangulatedPolygon, s::Integer, d::Integer)\n\nReturn true if g has an edge going from vertex s to vertex d. \n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.is_inner-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.is_inner","text":"is_inner(g::TriangulatedPolygon, e::Edge)\n\nReturn true if e is an inner edge in the TriangulatedPolygon.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.is_outer-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.is_outer","text":"is_outer(g::TriangulatedPolygon, e::Edge)\n\nReturn true if e is an outer edge in the TriangulatedPolygon.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.neighbors-Tuple{TriangulatedPolygon, Integer}","page":"Triangulations of Convex Polygons","title":"Graphs.neighbors","text":"neighbors(g::TriangulatedPolygon, v::Integer) :: Vector{Int32}\n\nReturn the list of all the vertices in g that are adjacent to v.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.is_identical-Tuple{TriangulatedPolygon, TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.is_identical","text":"is_identical(g1::TriangulatedPolygon, g2::TriangulatedPolygon)\n\nReturn true if 'g1' and 'g2' are the same triangulated polygon.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.rotate!-Tuple{TriangulatedPolygon, Integer}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.rotate!","text":"rotate!(g::TriangulatedPolygon, i::Integer)\n\nRotate g by i steps anticlockwise. \n\nA rotation by nv(g) would simply yield g again\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.mirror!-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.mirror!","text":"mirror!(g::TriangulatedPolygon)\n\nMirror g along the middle axis passing through g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"If you want to extrude some more information from a TriangulatedPolygon object, the following functions might be useful: ","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    degrees(::TriangulatedPolygon)\n    relative_degree(::TriangulatedPolygon, ::Integer, ::Vector{<:Integer})\n    relative_degrees(::TriangulatedPolygon, ::Vector{<:Integer}, ::Vector{<:Integer})\n    adjacency_matrix(::TriangulatedPolygon)\n    diameter(::TriangulatedPolygon)","category":"page"},{"location":"polygonTriangulation/#FlipGraphs.degrees-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.degrees","text":"degrees(g::TriangulatedPolygon) :: Vector{Int32}\n\nCompute a list of the degrees of every single vertex in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.relative_degree-Tuple{TriangulatedPolygon, Integer, Vector{var\"#s5\"} where var\"#s5\"<:Integer}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.relative_degree","text":"relative_degree(g::TriangulatedPolygon, u::Integer, V::Vector{<:Integer}) :: Vector{<:Integer}\n\nCount the number of edges in g going from u to a vertex in V.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.relative_degrees-Tuple{TriangulatedPolygon, Vector{var\"#s5\"} where var\"#s5\"<:Integer, Vector{var\"#s4\"} where var\"#s4\"<:Integer}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.relative_degrees","text":"relative_degrees(g::TriangulatedPolygon, U::Vector{<:Integer}, V::Vector{<:Integer}) :: Vector{<:Integer}\n\nCount, for each vertex in U, the number of incident edges, which are also incident to an edge in V.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.adjacency_matrix-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.adjacency_matrix","text":"adjacency_matrix(g::TriangulatedPolygon) :: Matrix{Int32}\n\nCompute the adjacency matrix for the triangulated graph g. \n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.diameter-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.diameter","text":"diameter(g::TriangulatedPolygon)\n\nCompute the diameter of the TriangulatedPolygon g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Flip-an-edge","page":"Triangulations of Convex Polygons","title":"Flip an edge","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    is_flippable(::TriangulatedPolygon, ::Integer, ::Integer)\n    is_flippable(::TriangulatedPolygon, ::Edge)\n    flip!(::TriangulatedPolygon, ::Integer, ::Integer)    \n    flip(::TriangulatedPolygon, ::Integer, ::Integer)\n    flip!(::TriangulatedPolygon, ::Edge)\n    flip(::TriangulatedPolygon, ::Edge)\n    flip_get_edge!","category":"page"},{"location":"polygonTriangulation/#FlipGraphs.is_flippable-Tuple{TriangulatedPolygon, Integer, Integer}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.is_flippable","text":"is_flippable(g::TriangulatedPolygon, src::Integer, dst::Integer) :: Bool\n\nReturn whether or not the edge can be flipped.\n\nNote that for a triangulation of a convex polygon, the inner edges are always flippable,      while the outer edges cannot be flipped.    \n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.is_flippable-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.is_flippable","text":"is_flippable(g::TriangulatedPolygon, e::Edge) :: Bool\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.flip!-Tuple{TriangulatedPolygon, Integer, Integer}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.flip!","text":"flip!(g::TriangulatedPolygon, src::Integer, dst::Integer) :: TriangulatedPolygon\n\nFlip the edge incident to src and dst in the triangulated convex polygon g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.flip-Tuple{TriangulatedPolygon, Integer, Integer}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.flip","text":"flip(g::TriangulatedPolygon, src::Integer, dst::Integer) :: TriangulatedPolygon\n\nReturn the TriangulatedPolygon obtained from g by flipping the edge incident to src and dst.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.flip!-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.flip!","text":"flip!(g::TriangulatedPolygon, e::Edge) :: TriangulatedPolygon\n\nFlip the edge e in the triangulated convex polygon g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.flip-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.flip","text":"flip(g::TriangulatedPolygon, e::Edge) :: TriangulatedPolygon\n\nReturn the triangulated polygon obtained by flipping the edge e in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.flip_get_edge!","page":"Triangulations of Convex Polygons","title":"FlipGraphs.flip_get_edge!","text":"flip_get_edge!(g::TriangulatedPolygon, src::Integer, dst::Integer) :: Tuple{Int32, Int32}\n\nFlip the edge incident to the vertices src and dst and return the new endpoints of the flipped edge.\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#Triangulations-of-Closed-Surfaces","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"","category":"section"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"DocTestSetup = quote\n    using FlipGraphs\nend","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"A triangulation of a closed surface is composed of points on the closed surface, which are connected by a maximal number of arcs (isotopy classes of curves on the surface that start and end at fixed points without containing any loops) in such a way, that no two arcs are homotopic to each other.\nAs these become very complex objects that are difficult and computationally complex to model, it is often more useful to look at the dual of a triangulation. This dual is called a Δ-complex. ","category":"page"},{"location":"deltaComplex/#DeltaComplex","page":"Triangulations of Closed Surfaces","title":"DeltaComplex","text":"","category":"section"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"A Δ-complex is a representation of a triangulation on a closed surface. To define a triangulation on a closed surface, it does not suffice to consider vertices and edges. We will also need to consider the triangular faces between them. Therefore, the triangulations are modeled using an extension of their dual graph.","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"Vertices are triangular faces, which in turn consist of three points and three edges. These points and edges are not necessarily distinct. Edges in the dual (i.e. the Δ-complex) connect two triangular faces if they, in turn, share an edge. To avoid confusion between the edges of the triangulation and the edges of the dual, I will henceforth refer to the latter as the dual edge.","category":"page"},{"location":"deltaComplex/#Structures","page":"Triangulations of Closed Surfaces","title":"Structures","text":"","category":"section"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    DeltaComplex\n    TriFace\n    DualEdge","category":"page"},{"location":"deltaComplex/#FlipGraphs.DeltaComplex","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.DeltaComplex","text":"struct DeltaComplex\n\nA graph data structure representing a triangulation of a surface.\n\nThe DeltaComplex may be thought of as the dual of a triangulation.\n\nVertices are triangular faces (TriFace). Every vertex has three edges (DualEdge) incident to it.\n\n\n\n\n\n","category":"type"},{"location":"deltaComplex/#FlipGraphs.TriFace","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.TriFace","text":"struct TriFace\n\nA TriFace represents a triangle in the triangulation of a surface. \n\nThe TriFaces form the vertices of a DeltaComplex. Each TriFace is formed between 3 points and is connected to 3 TriFaces through DualEdges. The points and neighboring triangles do not have to be unique.\n\nThe points and edges are stored in an anticlockwise order.\nThe first edge/side is between the first and second point.\nThe second edge/side is between the second and third point.\nThe third edge/side is between the third and first point.\n\n\n\n\n\n\n","category":"type"},{"location":"deltaComplex/#FlipGraphs.DualEdge","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.DualEdge","text":"struct DualEdge\n\nRepresentation of an edge in a DeltaComplex (i.e. the dual graph of a triangulation).\n\nA DualEdge connects two TriFaces through specific sides.\n\n\n\n\n\n","category":"type"},{"location":"deltaComplex/#Construction-of-a-DeltaComplex","page":"Triangulations of Closed Surfaces","title":"Construction of a DeltaComplex","text":"","category":"section"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"This Module comes with some handy and easy to use tools to construct a triangulation of a surface:","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    deltacomplex\n    deltacomplex_non_orientable\n    subdivide!(::DeltaComplex, ::Integer)","category":"page"},{"location":"deltaComplex/#FlipGraphs.deltacomplex","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.deltacomplex","text":"deltacomplex(genus :: Integer, num_points :: Integer = 1) :: DeltaComplex\n\nCreate a triangulation of an orientable surface of a certain genus with num_points points on it. \n\nBy default, num_points is set to 1.\n\n\n\n\n\ndeltacomplex(s :: Vector{<:Integer})\n\nCreate a triangulation of an orientable surface with a single point, by gluing the corresponding edges together.\n\ns should be an array of nonzero integers representing the edges of a polygon in anticlockwise order.\nThe i-th edge is orientated anticlockwise if s[i]>0 and anticlockwise if s[i]<0.\nIf s[i] and s[j] have the same absolute value, they are glued together while respecting their orientation.\n\nExamples\n\nThe following results in the triangulation of a torus with one point:\n\njulia> deltacomplex([1,2,-1,-2])\n\nThe following results in the triangulation of a klein bottle with one point:\n\njulia> deltacomplex([1,2,-1,2])\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#FlipGraphs.deltacomplex_non_orientable","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.deltacomplex_non_orientable","text":"deltacomplex_non_orientable(demigenus :: Integer, num_points :: Integer = 1) :: DeltaComplex\n\nCreate a triangulation of a non-orientable surface with num_points points on it. \n\nBy default, num_points is set to 1.\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#FlipGraphs.subdivide!-Tuple{DeltaComplex, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.subdivide!","text":"subdivide!(D::DeltaComplex, t::Integer)\n\nAdd a point to the inside of the t-th TriFace and connect it to each corner.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Extracting-information-from-DeltaComplex'","page":"Triangulations of Closed Surfaces","title":"Extracting information from DeltaComplex'","text":"","category":"section"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"DeltaComplex is not an implementation of Graphs.AbstractGraph. However, as it is similar to a simple graph, the same notation and function names were used for simplicity.","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    np(::DeltaComplex)\n    nv(::DeltaComplex)\n    ne(::DeltaComplex)\n    vertices(::DeltaComplex)\n    get_vertex(::DeltaComplex, ::Integer)\n    \n    edges(::DeltaComplex)\n    get_edge(::DeltaComplex, ::Integer)\n    get_edge(::DeltaComplex, ::Integer, ::Integer)\n\n    quadrilateral_edges(::DeltaComplex, ::DualEdge)\n\n    is_similar(::DualEdge, ::DualEdge)","category":"page"},{"location":"deltaComplex/#FlipGraphs.np-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.np","text":"np(D::DeltaComplex) :: Int\n\nReturn the number of points in the triangulation defined by D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.nv-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"Graphs.nv","text":"nv(D::DeltaComplex) :: Int\n\nReturn the number of vertices (TriFaces) in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.ne-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"Graphs.ne","text":"ne(D::DeltaComplex) :: Int\n\nReturn the number of edges (DualEdges) in the DeltaComplex D.\n\nThis is equal to the number of edges in the triangulation itself.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.vertices-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"Graphs.vertices","text":"vertices(D::DeltaComplex) :: Vector{TriFace}\n\nReturn the list of all vertices(TriFaces) in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_vertex-Tuple{DeltaComplex, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.get_vertex","text":"get_vertex(D::DeltaComplex, t::Integer) :: TriFace\n\nReturn the t-th TriFace in D\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.edges-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"Graphs.edges","text":"edges(D::DeltaComplex) :: Vector{DualEdge}\n\nReturn the list of all the DualEdges in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_edge-Tuple{DeltaComplex, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.get_edge","text":"get_edge(D::DeltaComplex, e::Integer) :: DualEdge\n\nReturn the e-th DualEdge in the DeltaComplex D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_edge-Tuple{DeltaComplex, Integer, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.get_edge","text":"get_edge(D::DeltaComplex, t::Integer, side::Integer) :: DualEdge\n\nReturn the edge that forms the respective side(1,2 or 3) of the t-th TriFace in the given DeltaComplex.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.quadrilateral_edges-Tuple{DeltaComplex, DualEdge}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.quadrilateral_edges","text":"quadrilateral_edges(D::DeltaComplex, diagonal::DualEdge) :: Tuple{DualEdge, DualEdge, DualEdge, DualEdge}\n\nReturn the 4 edges who form a quadrilateral with the given diagonal.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.is_similar-Tuple{DualEdge, DualEdge}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.is_similar","text":"is_similar(d1::DualEdge, d2::DualEdge) :: Bool\n\nReturn true if d1 and d2 have the same twist and are connected to the same triangles.\n\nThis is only the case if d1 and d2 are the same edge, or if they are incident to a point of degree 2.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Extracting-information-from-TriFaces","page":"Triangulations of Closed Surfaces","title":"Extracting information from TriFaces","text":"","category":"section"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"TriFaces form the vertices of a DeltaComplex. They are defined by their 3 edges. Additionally, they store the 3 points that form their corners.","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"As the TriFaces are stored in a list in DeltaComplex, each TriFace has its proper id which is the same as its index in the list.","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    id(::TriFace)","category":"page"},{"location":"deltaComplex/#FlipGraphs.id-Tuple{TriFace}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.id","text":"id(T::TriFace) :: Int\n\nReturn the index of the triangular face T in its DeltaComplex. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"If you wish to get the edges of a TriFace, you might want to use any of the following methods:","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    get_edge(::TriFace, ::Integer) \n    get_edge_id(::TriFace, ::Integer)\n    edges(::TriFace)    \n    edges_id(::TriFace)\n    edges(::DeltaComplex, ::Integer)\n    edges_id(::DeltaComplex, ::Integer) ","category":"page"},{"location":"deltaComplex/#FlipGraphs.get_edge-Tuple{TriFace, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.get_edge","text":"get_edge(T::TriFace, side::Integer) :: DualEdge\n\nReturn the DualEdge that is incident to the given side(1, 2 or 3) of the triangular face T.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_edge_id-Tuple{TriFace, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.get_edge_id","text":"get_edge_id(T::TriFace, side::Integer) :: Integer\n\nReturn the index of the DualEdges on the respective side(1, 2 or 3) of the triangular face T.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.edges-Tuple{TriFace}","page":"Triangulations of Closed Surfaces","title":"Graphs.edges","text":"edges(T::TriFace) :: Vector{DualEdge}\n\nReturn the list of all 3 DualEdges that are incident to the triangular face T. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.edges_id-Tuple{TriFace}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.edges_id","text":"edges_id(T::TriFace) :: Tuple{Int, Int, Int}\n\nReturn the indices of all 3 DualEdges that are incident to the TriFace T. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.edges-Tuple{DeltaComplex, Integer}","page":"Triangulations of Closed Surfaces","title":"Graphs.edges","text":"edges(D::DeltaComplex, t::Integer) :: Vector{DualEdge}\n\nReturn the list of all 3 DualEdges that are incident to the t-th TriFace in D. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.edges_id-Tuple{DeltaComplex, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.edges_id","text":"edges_id(D::DeltaComplex, t::Integer) :: Tuple{Int, Int, Int}\n\nReturn the indices of all 3 DualEdges that are incident to the t-th TriFace in D. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"If you wish to get the points that form the corners of a TriFace, you might want to use any of the following methods:","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    has_point(::TriFace, ::Integer)\n    get_point(::TriFace, ::Integer)\n    points(::TriFace)\n    points(::DeltaComplex, ::DualEdge)","category":"page"},{"location":"deltaComplex/#FlipGraphs.has_point-Tuple{TriFace, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.has_point","text":"has_point(T::TriFace, x::Integer) :: Bool\n\nReturn true if x forms one of the corners of the triangular face T\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_point-Tuple{TriFace, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.get_point","text":"get_point(T::TriFace, corner::Integer) :: Int\n\nReturn the point that is at the given corner(1, 2 or 3) of the triangular face T.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.points-Tuple{TriFace}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.points","text":"points(T::TriFace) :: Tuple{Int, Int, Int}\n\nReturn a tuple of the three points, that form the corners of T.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.points-Tuple{DeltaComplex, DualEdge}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.points","text":"points(D::DeltaComplex, d::DualEdge) :: Tuple{Int, Int}\n\nReturn both endpoints of the edge d in the triangulation defined by D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Extracting-information-from-DualEdges","page":"Triangulations of Closed Surfaces","title":"Extracting information from DualEdges","text":"","category":"section"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"DualEdges form the edges in a DeltaComplex. They are defined by the 2 triangles that form the endpoints and the respective sides through which they connect them. In addition, they may be twisted. (See Non-orientable closed surfaces for more on twisted edges) Contrary to a normal graph, it is important on which side of a TriFace an edge is incident to.","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"Like the TriFaces, DualEdges are also stored in a list in DeltaComplex, each DualEdge has its proper id which is the same as its index in the list.","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    id(::DualEdge)","category":"page"},{"location":"deltaComplex/#FlipGraphs.id-Tuple{DualEdge}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.id","text":"id(d::DualEdge) :: Int\n\nReturn the index of d in its DeltaComplex.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"If you wish to get the TriFaces that border the DualEdge, you might want to use any of the following methods:","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    vertices(::DeltaComplex, ::DualEdge)\n    vertices_id(::DualEdge)    \n    get_vertex_id(::DualEdge, ::Integer)\n    sides \n    get_side(::DualEdge, ::Integer)   \n    other_endpoint(::DualEdge, ::Integer, ::Integer)","category":"page"},{"location":"deltaComplex/#Graphs.vertices-Tuple{DeltaComplex, DualEdge}","page":"Triangulations of Closed Surfaces","title":"Graphs.vertices","text":"vertices(D::DeltaComplex, d::DualEdge) :: Tuple{TriFace, TriFace}\n\nReturn both vertices(TriFaces) adjacent to the dual edge d.\n\nThe first TriFace is on the left of the edge, and the second one on the right of the edge.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.vertices_id-Tuple{DualEdge}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.vertices_id","text":"vertices_id(d::DualEdge) :: Tuple{Int, Int}\n\nReturn the indices of both vertices (TriFaces) adjacent to d.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_vertex_id-Tuple{DualEdge, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.get_vertex_id","text":"get_vertex_id(d::DualEdge, side::Integer) :: Int\n\nReturn the index of the vertex (TriFace) to the left of d.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.sides","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.sides","text":"sides(d::DualEdge) :: Tuple{Int8, Int8}\n\nReturn the respective sides through which d connects its incident TriFaces.\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#FlipGraphs.get_side-Tuple{DualEdge, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.get_side","text":"get_side(d::DualEdge, side::Integer) :: Int8\n\nReturn the respective side of the triangle that d forms on the TriFace on the given side of d.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.other_endpoint-Tuple{DualEdge, Integer, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.other_endpoint","text":"other_endpoint(d::DualEdge, t::Integer, side::Integer) :: Tuple{Int, Int8}\n\nReturn the index of the other TriFace and its respective side, that is incident to d \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Classifying-the-triangulation","page":"Triangulations of Closed Surfaces","title":"Classifying the triangulation","text":"","category":"section"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"Here are some useful methods, to pull out general information about the Δ-Complex, and the triangulation it represents:","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    genus(::DeltaComplex)\n    euler_characteristic(::DeltaComplex)\n    diameter_triangulation(::DeltaComplex)\n    diameter_deltaComplex(::DeltaComplex)\n    diameter(::DeltaComplex)\n    adjacency_matrix_deltacomplex(::DeltaComplex)\n    multi_adjacency_matrix_deltacomplex(::DeltaComplex)\n    adjacency_matrix_triangulation(::DeltaComplex)\n    multi_adjacency_matrix_triangulation(::DeltaComplex)","category":"page"},{"location":"deltaComplex/#FlipGraphs.genus-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.genus","text":"genus(D::DeltaComplex) :: Int\n\nCompute the genus of the DeltaComplex D if it forms an orientable surface.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.euler_characteristic-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.euler_characteristic","text":"euler_characteristic(D::DeltaComplex) :: Int\n\nCompute the euler characteristic of the DeltaComplex D:\n\nX = n_vertices - n_edges + n_faces \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.diameter_triangulation-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.diameter_triangulation","text":"diameter_triangulation(D::DeltaComplex)\n\nCompute the diameter of the triangulation defined by the DeltaComplex D.\n\nThe diameter of a graph is the greatest minimal distance between any 2 vertices.\n\nSee also diameter_deltaComplex\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.diameter_deltaComplex-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.diameter_deltaComplex","text":"diameter_deltacomplex(D::DeltaComplex)\n\nCompute the diameter of the DeltaComplex D.\n The diameter of a graph is the greatest minimal distance between any 2 vertices.\n\nSee also diameter_triangulation\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.diameter-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.diameter","text":"diameter(D::DeltaComplex)\n\nCompute the diameter of the DeltaComplex D.\n The diameter of a graph is the greatest minimal distance between any 2 vertices.\n\nSee also diameter_triangulation\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.adjacency_matrix_deltacomplex-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.adjacency_matrix_deltacomplex","text":"adjacency_matrix_deltacomplex(D::DeltaComplex) :: Matrix{::Int32}\n\nCompute the simple adjacency matrix of the delta complex D.\n\nValues are either 0(not adjacent) or 1(adjacent).\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.multi_adjacency_matrix_deltacomplex-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.multi_adjacency_matrix_deltacomplex","text":"multi_adjacency_matrix_deltacomplex(D::DeltaComplex) :: Matrix{Int32}\n\nCompute the multi adjacency matrix of the delta complex D.\n\nThe i,j-th value counts the number of sides through which the i-th and j-th TriFace are adjacent.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.adjacency_matrix_triangulation-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.adjacency_matrix_triangulation","text":"adjacency_matrix_triangulation(D::DeltaComplex) :: Matrix{Int32}\n\nCompute the simple adjacency matrix of the triangulation defined by D.\n\nAll entries are either 0 or 1.\n\nSee also multi_adjacency_matrix_triangulation\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.multi_adjacency_matrix_triangulation-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.multi_adjacency_matrix_triangulation","text":"multi_adjacency_matrix_triangulation(D::DeltaComplex) :: Matrix{Int32}\n\nCompute the adjacency matrix of the multigraph of the triangulation defined by D.\n\nThe ij-th entry notes the number of edges that connect these two points.\n\nSee also adjacency_matrix_triangulation\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    point_degrees(::DeltaComplex)","category":"page"},{"location":"deltaComplex/#FlipGraphs.point_degrees-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.point_degrees","text":"point_degrees(D::DeltaComplex) :: Vector{<:Integer}\n\nReturn a vector containing the respective degree of each point in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Relabeling","page":"Triangulations of Closed Surfaces","title":"Relabeling","text":"","category":"section"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"If you want to relabel/reorder the points, vertices or edges, you may do so, by providing a permutation vector p=p_1 p_2 ldots  p_n which will relabel i as p_i. ","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    rename_edges!(::DeltaComplex, ::Vector{<:Integer})\n    rename_points!(::DeltaComplex, ::Vector{<:Integer})\n    rename_vertices!(::DeltaComplex, ::Vector{<:Integer})","category":"page"},{"location":"deltaComplex/#FlipGraphs.rename_edges!-Tuple{DeltaComplex, Vector{var\"#s4\"} where var\"#s4\"<:Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.rename_edges!","text":"rename_edges!(D::DeltaComplex, p::Vector{<:Integer})\n\nRelabel every edge(DualEdge) in D, according to the permutation p.\n\nDualEdge 1 => DualEdge p1\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.rename_points!-Tuple{DeltaComplex, Vector{var\"#s4\"} where var\"#s4\"<:Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.rename_points!","text":"rename_points!(D::DeltaComplex, p::Vector{<:Integer})\n\nRename all the points in D according to the permutation p.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.rename_vertices!-Tuple{DeltaComplex, Vector{var\"#s4\"} where var\"#s4\"<:Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.rename_vertices!","text":"rename_vertices!(D::DeltaComplex, p::Vector{<:Integer})\n\nRelabel every vertex(TriFace) in D, according to the permutation p.\n\nTriFace 1 => TriFace p1 \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Non-orientable-closed-surfaces","page":"Triangulations of Closed Surfaces","title":"Non-orientable closed surfaces","text":"","category":"section"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"Regarding on how different sides of triangles are associated to each other, the resulting surface may be non-orientable. These surfaces can also be modeled by DeltaComplex, and all the methods above (except for genus) may still be applied.","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    is_orientable(::DeltaComplex)\n    demigenus\n    twist_edges!\n    is_twisted","category":"page"},{"location":"deltaComplex/#FlipGraphs.is_orientable-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.is_orientable","text":"is_orientable(D::DeltaComplex) :: Bool\n\nCheck if the surface defined by D is orientable or not.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.demigenus","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.demigenus","text":"demigenus(D::DeltaComplex) :: Int\n\nCompute the demigenus of the DeltaComplex D if it is non-orientable.\n\nThe demigenus or non-orientable genus (k) of a connected non-orientable closed surface is defined via the euler characteristic (X) :\nk = 2 - X\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#FlipGraphs.twist_edges!","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.twist_edges!","text":"twist_edges!(D::DeltaComplex, t::Integer)\ntwist_edges!(T::TriFace)\n\nTwist or untwist all 3 DualEdges of a TriFace, and reverse the side order.\n\nThis action gives an equivalent representation of the same triangulation. It is useful in the case that you would like to untwist a certain edge.\n\nExamples\n\njulia> D = deltacomplex([1,2,-1,2]);\njulia> T = get_vertex(D,1);\njulia> edges(T)\n3-element Array{DualEdge,1}:\n DualEdge 2 : (Δ1)-(1)-------(2)-(Δ2)\n DualEdge 1 : (Δ1)-(2)-------(3)-(Δ2)\n DualEdge 3 : (Δ2)-(1)---↺---(3)-(Δ1)\n julia> twist_edges!(T);\n julia> edges(T)\n 3-element Array{DualEdge,1}:\n DualEdge 3 : (Δ2)-(1)-------(1)-(Δ1)\n DualEdge 1 : (Δ1)-(2)---↺---(3)-(Δ2)\n DualEdge 2 : (Δ1)-(3)---↺---(2)-(Δ2)\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#FlipGraphs.is_twisted","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.is_twisted","text":"is_twisted(d::DualEdge) :: Bool\n\nReturn whether or not the given edge is twisted. \n\nIf d is twisted, then everything on the other side gets regarded as its mirror image. \n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#Flipping","page":"Triangulations of Closed Surfaces","title":"Flipping","text":"","category":"section"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"A flip is defined as the action of replacing an edge in the triangulation by the other diagonal of the quadrilateral formed by the two triangles adjacent to the edge.","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"It has been shown, that the flip graph of any closed surface is connected. Hence, it is possible, to obtain any triangulation by a finite number of flips.","category":"page"},{"location":"deltaComplex/","page":"Triangulations of Closed Surfaces","title":"Triangulations of Closed Surfaces","text":"    flip(::DeltaComplex, ::Integer)\n    flip!(::DeltaComplex, ::Integer)\n    flip!(::DeltaComplex, ::DualEdge; ::Bool)\n    is_flippable(::DeltaComplex, ::Integer)\n    is_flippable(::DualEdge)\n    random_flips!(::DeltaComplex, ::Integer)\n    randomize!(::DeltaComplex; ::Integer, ::Integer, ::Integer, ::Integer)","category":"page"},{"location":"deltaComplex/#FlipGraphs.flip-Tuple{DeltaComplex, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.flip","text":"flip(D::DeltaComplex, e::Integer) :: DeltaComplex\n\nReturn the resulting DeltaComplex obtained by flipping the given edge in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.flip!-Tuple{DeltaComplex, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.flip!","text":"flip!(D::DeltaComplex, e::Integer)\n\nFlip, if possible, the given edge in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.flip!-Tuple{DeltaComplex, DualEdge}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.flip!","text":"flip!(D::DeltaComplex, d::DualEdge)\n\nFlip, if possible, the given edge in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.is_flippable-Tuple{DeltaComplex, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.is_flippable","text":"is_flippable(D::DeltaComplex, e::Integer) :: Bool\n\nReturn true if the given edge can be flipped.\n\nThis is always the case if the edge does not connect a TriFace to itself.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.is_flippable-Tuple{DualEdge}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.is_flippable","text":"is_flippable(d::DualEdge)\n\nReturn true if the given edge can be flipped.\n\nThis is always the case if the edge does not connect a TriFace to itself.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.random_flips!-Tuple{DeltaComplex, Integer}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.random_flips!","text":"random_flips!(D::DeltaComplex, n::Integer)\n\nRandomly pick an edge, and flip it if possible. Repeat this n times.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.randomize!-Tuple{DeltaComplex}","page":"Triangulations of Closed Surfaces","title":"FlipGraphs.randomize!","text":"randomize!(D::DeltaComplex; kwargs...) -> Int\n\nRandomly flip edges in D until D is sufficiently generic and return the number of attempted flips.\n\nThe measure by which we determine if D is sufficiently generic is through its diameter. This Method repeatedly flips a certain number of times. After each flip sequence, the diameter is computed. Once this was repeated a certain number of times, the variance of all these past diameter measurements gets computed.\n\nIn theory, the variance should diminish over time. However, as we are flipping randomly, it will never truly converge to 0. A certain flutter in the variance is expected, this will at some point cause the variance to increase every so often. The algorithm stops once the last measured variance is bigger than the past few measurements.\n\nArguments\n\nnum_initial_flips::Integer=1000000 : the number of flips to do before even start taking measurements.\nnum_flips_per_step::Integer=10000 : the number of flips to do before computing the diameter each step.\nvariance_interval_size::Integer=10 : the number of diameters to store, before computing their variance. \nlookback_size::Integer=2 : how far back to compare the current variance to, in order to decide when to stop. \n\nExamples\n\njulia> D = deltacomplex(30,30);\njulia> randomize!(D, num_initial_flips=10000, num_flips_per_step = 1000, variance_interval_size=10, lookback_size = 5)\n160000\n\n\n\n\n\n","category":"method"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"DocTestSetup = quote\n    using FlipGraphs\nend","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"To install the package, you first need to install Julia.  After starting Julia, type the following:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using Pkg \njulia> Pkg.add(\"FlipGraphs\")","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"You can start using the package as follows:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using FlipGraphs\njulia> D = deltacomplex(4,10);\nDeltaComplex on orientable surface of genus 4 with 10 points\n32 TriFaces:\n TriFace #1: Points(1 1 2) Neighbors(5 15 16)\n TriFace #2: Points(1 1 3) Neighbors(20 17 18)\n ⋮\n TriFace #31: Points(1 1 10) Neighbors(10 32 9)\n TriFace #32: Points(1 1 10) Neighbors(8 9 31)\n48 DualEdges:\n DualEdge 1 : (Δ15)-(1)-------(1)-(Δ18)\n DualEdge 2 : (Δ2)-(1)-------(1)-(Δ20)\n ⋮\n DualEdge 47 : (Δ9)-(2)-------(3)-(Δ31)\n DualEdge 48 : (Δ31)-(2)-------(3)-(Δ32)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you need help understanding what a function does or what a structure represents, you can put a question mark in front of it:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> ?FlipGraph\n  struct FlipGraph <: AbstractGraph{Int}\n\n  A Graph representing the flip graph of a Δ-Complex.\n\n  Vertices are isotopy classes of triangulations of the same surface.\n  Two vertices are linked by an edge, if the respective triangulations differ only by a single flip.","category":"page"},{"location":"exporting/#Exporting","page":"Exporting","title":"Exporting","text":"","category":"section"},{"location":"exporting/","page":"Exporting","title":"Exporting","text":"DocTestSetup = quote\n    using FlipGraphs\nend","category":"page"},{"location":"exporting/","page":"Exporting","title":"Exporting","text":"    export_gml","category":"page"},{"location":"exporting/#FlipGraphs.export_gml","page":"Exporting","title":"FlipGraphs.export_gml","text":"export_gml(fpn::String, G::AbstractGraph{::Integer}, kwargs...)\n\nSave the graph G as a .gml file.\n\nG can be either a FlipGraph or FlipGraphPlanar.\n\nArguments\n\nvertex_attributes::Vector{Dict} : If provided, the i-th vertex gets the attributes from the i-th Dict.                                    Each key, value pair defines an attribute, where the key is the name of the attribute and value is its value.\nedge_attributes::Vector{Dict}   : If provided, the i-th edge gets the attributes from the i-th Dict.                                    Each key, value pair defines an attribute, where the key is the name of the attribute and value is its value.\nadd_diameter = false :            If set to true, every vertex in the exported tree gets an attribute called diameter with the respective diameter of the DeltaComplex of that vertex.\n\nExamples\n\njulia> G = flipgraph_planar(10);\njulia> export_gml(\"C:/Users/USERNAME/Desktop/filename.gml\", G);\n\nBy adding the additional symbol :diameter, the nodes get a value diameter which corresponds to the diameter of the DeltaComplex or TriangulatedPolygon it models. Be aware however, that this diameter is computed on the run and will therefore significantly slow down this export method.\n\njulia> G = flipgraph_modular(1,3,labeled_points = true);\njulia> export_gml(\"C:/Users/USERNAME/Desktop/filename.gml\", G, add_diameter=true);\n\n\n\n\n\n","category":"function"},{"location":"flipGraph/#Modular-Flip-Graphs-of-Closed-Orientable-Surfaces","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"","category":"section"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"DocTestSetup = quote\n    using FlipGraphs\nend","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"Contrary to flip graphs of planar triangulations like that of a convex polygon, the flip graph of a closed surface is generally infinitely large. Therefore, it is impossible to construct the whole flip graph. Not only are they infinitely large, but they also \"grow\" very fast. For this reason, it is more interesting and achievable to look at the modular flip graphs. These are graphs whose vertices are homotopy classes of triangulations on closed surfaces.","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"It turns out that the vertices of modular flip graphs are equivalent to the Δ-coplexes which we have already modeled in DeltaComplex.","category":"page"},{"location":"flipGraph/#Structures","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Structures","text":"","category":"section"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"A FlipGraph consists of vertices that represent homotopy classes of DeltaComplexes and edges between them.  In order to be able to efficiently compute the whole flip graph, vertices are not DeltaComplexes but have their own structure (FGVertex) which consists of a DeltaComplex with additional information.","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"    FlipGraph\n    FGVertex","category":"page"},{"location":"flipGraph/#FlipGraphs.FlipGraph","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"FlipGraphs.FlipGraph","text":"struct FlipGraph <: AbstractGraph{Int}\n\nA graph representing the flip graph of a Δ-Complex.\n\nVertices are isotopy classes of triangulations of the same surface.\nTwo vertices are linked by an edge, if the respective triangulations differ only by a single flip.\n\n\n\n\n\n","category":"type"},{"location":"flipGraph/#FlipGraphs.FGVertex","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"FlipGraphs.FGVertex","text":"struct FGVertex\n\nA vertex in a FlipGraph. \n\nA FGVertex is composed of a representant (DeltaComplex) of the isotopy class of that vertex.  The representant has been relabeled with one of the canonical labeling obtained by an adaptation of McKay's Algorithm. Additionally, the FGVertex contains the number of labeling that are output by the respective McKay's Algorithms.\n\n\n\n\n\n","category":"type"},{"location":"flipGraph/#Constructors","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Constructors","text":"","category":"section"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"Currently, it is only possible to create the modular flip graph of a closed orientable surface. Non-orientable surfaces would need an adapted approach to solving, as the way they are modeled right now would require a lot more options to be checked just to determine if two DeltaComplexes are isomorphic to each other.","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"As even modular flip graphs become very large quite quickly, you have the possibility of only building a local portion of a flip graph. The way this works is, by giving it a DeltaComplex, which forms the root vertex, and setting the depth, which will limit the vertices to only include those that are at a distance less or equal to this depth from the root.","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"    flipgraph_modular","category":"page"},{"location":"flipGraph/#FlipGraphs.flipgraph_modular","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"FlipGraphs.flipgraph_modular","text":"flipgraph_modular(g::Integer, p::Integer; kwargs..) :: FlipGraph\n\nConstruct the modular flip graph for a genus g closed orientable surface with p points on it.  \n\nArguments\n\nlabeled_points :: Bool = true : If set to false, the isomorphism also includes a renaming of the points. \n\n\n\n\n\nflipgraph_modular(D::DeltaComplex; kwargs..)\n\nConstruct the modular flip graph for the closed orientable surface defined by the Δ-complex D.  \n\nArguments\n\nlabeled_points :: Bool = true : If is set to false, then the isomorphism also includes a renaming of the points. \ndepth :: Integer = ∞ : Determines the depth to which the flip graph should be constructed. i.e. up to which distance from D. \n\n\n\n\n\n","category":"function"},{"location":"flipGraph/#Graph-methods","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Graph methods","text":"","category":"section"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"As with FlipGraphPlanar, there are a bunch of methods which overload some of the main functions from the Graphs.jl package.","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"    nv(::FlipGraph)\n    ne(::FlipGraph)\n    vertices(::FlipGraph)\n    vertices_deltacomplex\n    edges(::FlipGraph)\n    has_vertex(::FlipGraph, ::Integer)\n    get_vertex(::FlipGraph, ::Integer)\n    has_edge(::FlipGraph,::Edge)\n    has_edge(::FlipGraph,::Integer, ::Integer)    \n    has_edge(::FlipGraph,::FGVertex, ::FGVertex)\n    neighbors(::FlipGraph, ::Integer)    \n    degree(::FlipGraph, ::Integer)\n    diameter(::FlipGraph)","category":"page"},{"location":"flipGraph/#Graphs.nv-Tuple{FlipGraph}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Graphs.nv","text":"nv(G::FlipGraph) :: Int\n\nReturn the number of vertices in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.ne-Tuple{FlipGraph}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Graphs.ne","text":"ne(G::FlipGraph) :: Int\n\nReturn the number of edges in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.vertices-Tuple{FlipGraph}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Graphs.vertices","text":"vertices(G::FlipGraph) :: Vector{FGVertex}\n\nReturn the list of all the vertices that have been constructed in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraphs.vertices_deltacomplex","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"FlipGraphs.vertices_deltacomplex","text":"vertices_deltacomplex(G::FlipGraph) :: Vector{DeltaComplex}\n\nConstruct a list of all the DeltaComplexs which form the vertices in G.\n\n\n\n\n\n","category":"function"},{"location":"flipGraph/#Graphs.edges-Tuple{FlipGraph}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Graphs.edges","text":"edges(G::FlipGraph) :: Vector{Edge}\n\nConstruct a list containing all the edges in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.has_vertex-Tuple{FlipGraph, Integer}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Graphs.has_vertex","text":"has_vertex(G::FlipGraph, v::Integer) :: Bool\n\nReturn true if v is a valid index of a vertex in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraphs.get_vertex-Tuple{FlipGraph, Integer}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"FlipGraphs.get_vertex","text":"get_vertex(G::FlipGraph, id::Integer) :: Vector{FGVertex}\n\nReturn the id-th vertex of the FlipGraph G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.has_edge-Tuple{FlipGraph, Graphs.SimpleGraphs.SimpleEdge}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Graphs.has_edge","text":"has_edge(G::FlipGraph, e::Edge) :: Bool\n\nReturn true if e is an edge in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.has_edge-Tuple{FlipGraph, Integer, Integer}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Graphs.has_edge","text":"has_edge(G::FlipGraph, s::Integer, d::Integer) :: Bool\n\nReturn true if there is an edge between the s-th and d-th vertex in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.has_edge-Tuple{FlipGraph, FGVertex, FGVertex}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Graphs.has_edge","text":"has_edge(G::FlipGraph, v1::FGVertex, v2::FGVertex) :: Bool\n\nReturn true if there is an edge between v1 and v2 in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.neighbors-Tuple{FlipGraph, Integer}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Graphs.neighbors","text":"neighbors(G::FlipGraph, v::Integer) :: Vector{Int32}\n\nReturn a list of the indices of all the neighboring vertices of the v-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraphs.degree-Tuple{FlipGraph, Integer}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"FlipGraphs.degree","text":"degree(G::FlipGraph, v::Integer)\n\nReturn the degree of the v-th vertex in the graph G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraphs.diameter-Tuple{FlipGraph}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"FlipGraphs.diameter","text":"diameter(G::FlipGraph)\n\nCompute the diameter of the FlipGraph G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Comparing-Triangulations","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Comparing Triangulations","text":"","category":"section"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"One problem in deciding if two triangulations are equivalent, is that the naming of the vertices, edges and points is completely arbitrary. In the act of flipping, DualEdges and TriFaces \"move around\". It is therefore possible to obtain two DeltaComplexes representing the same triangulation of a surface but with different labeled TriFaces and DualEdges. ","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"The following method will determine if two DeltaComplexes are isomorphic to each other and therefore represent the same vertex in the modular flip graph:","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"    is_isomorphic(::DeltaComplex, ::DeltaComplex)","category":"page"},{"location":"flipGraph/#FlipGraphs.is_isomorphic-Tuple{DeltaComplex, DeltaComplex}","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"FlipGraphs.is_isomorphic","text":"is_isomorphic(D1::DeltaComplex, D2::DeltaComplex; kwargs..) :: Bool\n\nReturn true if D1 is isomorph to D2 up to a renaming of the vertices, edges and if labeled_points=false also points.\n\nArguments\n\nlabeled_points :: Bool = true : If labeled_points is set to false, then the isomorphism also includes a renaming of the points. \n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Canonical-labeling-of-DeltaComplexes","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Canonical labeling of DeltaComplexes","text":"","category":"section"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"Checking every possible permutation of TriFace and DualEdge labeling was not an option, as the number of possibilities would blow up immediately. ","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"What one can do instead is try to find a canonical labeling. This module uses a version of McKay's canonical graph labeling algorithm[1] to try and determine a unique labeling based on the relationship of vertices and edges to other vertices and edges. In general, it is not always possible to determine a unique labeling. However, with this method, we can reduce the number of labelings to a manageable number.","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"The mcKay methods each return a permutation vector p which can be interpreted as a Cauchy's one-line notation for permutations.  For example, p = [3,5,1,2,6,4] would correspond to the following permutation:","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"σ = beginpmatrix\n1  2  3  4  5  6\n3  5  1  2  6  4\nendpmatrix = (1 3)(2 5 6 4)","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"This algorithm has been adapted to find canonical labelings for points, vertices and edges. These are not independent from each other. In fact, only the point labelings depend on themselves. mcKayvertices will give different results basedon the point labelings, and mcKayedges will give different results based on both point and vertex labelings. Therefore, they are to be used in sequence.","category":"page"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"    mcKay_points\n    mcKay_vertices\n    mcKay_edges","category":"page"},{"location":"flipGraph/#FlipGraphs.mcKay_points","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"FlipGraphs.mcKay_points","text":"mcKay_points(D::DeltaComplex; kwargs..) :: Vector{Vector{Int32}}\n\nApply a version of McKay's canonical graph labeling algorithm to determine all possible permutations  of the points which give a canonical isomorphism class representant.\n\nReturn a vector of permutation vectors p such that point 1 becomes point p[1], point 2 becomes point p[2],...\n\nArguments\n\nonly_one :: Bool = false, If set to true, the algorithm will stop after finding a single valid permutation.\n\n\n\n\n\n","category":"function"},{"location":"flipGraph/#FlipGraphs.mcKay_vertices","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"FlipGraphs.mcKay_vertices","text":"mcKay_vertices(D::DeltaComplex; , A_deltacomplex::Matrix{<:Integer}, point_perm::Vector{<:Integer}) :: Vector{Vector{Int32}}\n\nApply a version of McKay's canonical graph labeling algorithm in order to determine all possible permutations  of the TriFaces which give a canonical isomorphism class representant.\n\nReturn a vector of permutation vectors p such that TriFace 1 becomes TriFace p[1], TriFace 2 becomes TriFace p[2], ...\nIf only_one=true, the algorithm stops after finding one valid permutation.\n\nThe vectors point_perm determins how the points of D are implied to have been renamed, without actually having been changed.\n\n\n\n\n\nmcKay_vertices(D::DeltaComplex; kwargs..) :: Vector{Vector{Int32}}\n\nApply a version of McKay's canonical graph labeling algorithm in order to determine all possible permutations  of the TriFaces which give a canonical isomorphism class representant.\n\nReturn a vector of permutation vectors p such that TriFace 1 becomes TriFace p[1], TriFace 2 becomes TriFace p[2], ...\nIf only_one=true, the algorithm stops after finding one valid permutation.\n\nArguments\n\nonly_one :: Bool = false, If set to true, the algorithm will stop after finding a single valid permutation.\nA_deltacomplex :: Matrix{<:Integer} = Matrix{Int32}(adjacencymatrixdeltacomplex(D)). If provided, the algorithm will use the adjacency matrix of the DeltaComplex D. If not, the algorithm would have to compute it itself.\n\n\n\n\n\n","category":"function"},{"location":"flipGraph/#FlipGraphs.mcKay_edges","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"FlipGraphs.mcKay_edges","text":"mcKay_edges(D::DeltaComplex; kwargs..) :: Vector{Vector{Int32}}\n\nApply McKay's canonical graph labeling algorithm in order to determine all possible permutations  of the DualEdges which give a canonical isomorphism class representant.\n\nReturn a vector of permutation vectors p such that DualEdge 1 becomes DualEdge p[1], DualEdge 2 becomes DualEdge p[2], ...\n\n\nArguments\n\nonly_one :: Bool = false, If set to true, the algorithm will stop after finding a single valid permutation.\n\n\n\n\n\n","category":"function"},{"location":"flipGraph/","page":"Modular Flip Graphs of Closed Orientable Surfaces","title":"Modular Flip Graphs of Closed Orientable Surfaces","text":"[1]: Hartke, S.G., & Radcliffe, A.J. (2008). McKay ’ s Canonical Graph Labeling Algorithm.","category":"page"},{"location":"flipGraphPlanar/#Flip-Graphs-of-Convex-Polygons","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"","category":"section"},{"location":"flipGraphPlanar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"Flip Graphs, are obtained by considering triangulations on a fixed set of points as vertices, and connecting two vertices, if it is possible to get from one triangulation to the other by flipping a single edge.","category":"page"},{"location":"flipGraphPlanar/#Structures","page":"Flip Graphs of Convex Polygons","title":"Structures","text":"","category":"section"},{"location":"flipGraphPlanar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"The main structure for this part of the package is the FlipGraphPlanar structure.  This implements the AbstractGraph interface from Graphs.jl.  It is therefore possible to use it with other packages that work with Graphs.jl.","category":"page"},{"location":"flipGraphPlanar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"    FlipGraphPlanar","category":"page"},{"location":"flipGraphPlanar/#FlipGraphs.FlipGraphPlanar","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.FlipGraphPlanar","text":"struct FlipGraphPlanar <: AbstractGraph{Int32}\n\nA Graph representing the flip graph of a convex polygon. \n\nVertices are different triangulations of the same convex polygon. Two vertices are linked by an edge, if the respective graphs differ only by a single flip.\n\n\n\n\n\n","category":"type"},{"location":"flipGraphPlanar/#Constructors","page":"Flip Graphs of Convex Polygons","title":"Constructors","text":"","category":"section"},{"location":"flipGraphPlanar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"To construct the flip graph of a convex polygon, you can either start from a TriangulatedPolygon or just set the number of vertices of the triangulated convex polygon.","category":"page"},{"location":"flipGraphPlanar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"    flipgraph(::TriangulatedPolygon)\n    flipgraph_planar","category":"page"},{"location":"flipGraphPlanar/#FlipGraphs.flipgraph-Tuple{TriangulatedPolygon}","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.flipgraph","text":"flipgraph(g::TriangulatedPolygon; kwargs..)\n\nConstruct the FlipGraph for the TriangulatedPolygon g.\n\nArguments\n\n'modular::Bool = false' : by default, the whole flip graph is constructed. If modular is set to true, then only the modular flip graph is constructed.\n\nIn a modular flip graph, vertices of the flip graph are classes of isomorphisms up to renaming the vertices.  Each class is then represented by one of its elements.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#FlipGraphs.flipgraph_planar","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.flipgraph_planar","text":"flipgraph_planar(n::Integer; modular=false) :: FlipGraphPlanar\n\nConstruct the FlipGraphPlanar of a convex n-gon. \n\nIf modular=true, the flip graph is reduced to its modular form.\n\nExamples\n\njulia> flipgraph_planar(6)\nFlipGraphPlanar with 14 vertices and 21 edges\n\n\n\n\n\n","category":"function"},{"location":"flipGraphPlanar/#Graph-methods","page":"Flip Graphs of Convex Polygons","title":"Graph methods","text":"","category":"section"},{"location":"flipGraphPlanar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"The following methods overload some of the main functions from the Graphs.jl package.","category":"page"},{"location":"flipGraphPlanar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"    nv(::FlipGraphPlanar)\n    ne(::FlipGraphPlanar)\n    vertices(::FlipGraphPlanar)\n    edges(::FlipGraphPlanar)   \n    has_vertex(::FlipGraphPlanar,::TriangulatedPolygon)\n    has_vertex(::FlipGraphPlanar,::Integer)\n    get_vertex(::FlipGraphPlanar, ::Integer)\n    has_edge(::FlipGraphPlanar,s,d)\n    has_edge(::FlipGraphPlanar,::Edge)\n\n    degree(::FlipGraphPlanar, ::Integer)\n    neighbors(::FlipGraphPlanar, ::Integer)\n    diameter(::FlipGraphPlanar)","category":"page"},{"location":"flipGraphPlanar/#Graphs.nv-Tuple{FlipGraphPlanar}","page":"Flip Graphs of Convex Polygons","title":"Graphs.nv","text":"nv(G::FlipGraphPlanar)\n\nReturn the number of vertices in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#Graphs.ne-Tuple{FlipGraphPlanar}","page":"Flip Graphs of Convex Polygons","title":"Graphs.ne","text":"ne(G::FlipGraphPlanar)\n\nReturn the number of edges in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#Graphs.vertices-Tuple{FlipGraphPlanar}","page":"Flip Graphs of Convex Polygons","title":"Graphs.vertices","text":"vertices(G::FlipGraphPlanar)\n\nReturn the List of all vertices in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#Graphs.edges-Tuple{FlipGraphPlanar}","page":"Flip Graphs of Convex Polygons","title":"Graphs.edges","text":"edges(G::FlipGraphPlanar) ::Vector{Edge}\n\nConstruct an array containing all the edges in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#Graphs.has_vertex-Tuple{FlipGraphPlanar, TriangulatedPolygon}","page":"Flip Graphs of Convex Polygons","title":"Graphs.has_vertex","text":"has_vertex(G::FlipGraphPlanar, g::TriangulatedPolygon) :: Bool\n\nReturn true if g is a vertex in G. \n\nIf G is a modular flip graph, this will only return true if g is the proper representant of the vertex.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#Graphs.has_vertex-Tuple{FlipGraphPlanar, Integer}","page":"Flip Graphs of Convex Polygons","title":"Graphs.has_vertex","text":"has_vertex(G::FlipGraphPlanar, i::Integer) :: Bool\n\nReturn true if i is a valid index of a vertex in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#FlipGraphs.get_vertex-Tuple{FlipGraphPlanar, Integer}","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.get_vertex","text":"get_vertex(G::FlipGraphPlanar, i::Integer) :: TriangulatedPolygon\n\nReturn the i-th vertex in the planar flip graph G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#Graphs.has_edge-Tuple{FlipGraphPlanar, Any, Any}","page":"Flip Graphs of Convex Polygons","title":"Graphs.has_edge","text":"has_edge(G::FlipGraphPlanar, s, d)\n\nReturn true if there is an edge between s and d in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#Graphs.has_edge-Tuple{FlipGraphPlanar, Graphs.SimpleGraphs.SimpleEdge}","page":"Flip Graphs of Convex Polygons","title":"Graphs.has_edge","text":"has_edge(G::FlipGraphPlanar, e::Edge)\n\nReturn true if e is an edge in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#FlipGraphs.degree-Tuple{FlipGraphPlanar, Integer}","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.degree","text":"degree(G::FlipGraphPlanar, v::Integer)\n\nReturn the degree of the v-th vertex in the graph G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#Graphs.neighbors-Tuple{FlipGraphPlanar, Integer}","page":"Flip Graphs of Convex Polygons","title":"Graphs.neighbors","text":"neighbors(G::FlipGraphPlanar, v::Integer) :: Vector{Int32}\n\nReturn a list of all the indices of vertices in G, that are adjacent to v.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#FlipGraphs.diameter-Tuple{FlipGraphPlanar}","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.diameter","text":"diameter(G::FlipGraphPlanar)\n\nCompute the diameter of G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#Comparing-Triangulations","page":"Flip Graphs of Convex Polygons","title":"Comparing Triangulations","text":"","category":"section"},{"location":"flipGraphPlanar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"To compute the flip graph, one needs to be able to determine if two triangulations are identical (if the points are labeled) or isomorphic to each other (if the points are unlabeled). \nThe first case is fairly simple, as two triangulations are identical if their adjacency lists are. The only difficulty here is that the order in the list of neighbors is not fixed.\nThe second case is more challenging, as there are n different ways to label n points. The way it is done in this package is to use a variation of McKay's canonical graph labeling algorithm[1] to rattle the number of possible labelings down to a relatively small number.","category":"page"},{"location":"flipGraphPlanar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"    is_isomorphic(::TriangulatedPolygon, ::TriangulatedPolygon)\n    is_isomorphic(::TriangulatedPolygon, ::TriangulatedPolygon, ::Array{Vector{T},1}) where T<:Integer","category":"page"},{"location":"flipGraphPlanar/#FlipGraphs.is_isomorphic-Tuple{TriangulatedPolygon, TriangulatedPolygon}","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.is_isomorphic","text":"is_isomorphic(g1::TriangulatedPolygon, g2::TriangulatedPolygon)\n\nCheck if g1 and g2 are isomorphic up to a relabeling of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#FlipGraphs.is_isomorphic-Union{Tuple{T}, Tuple{TriangulatedPolygon, TriangulatedPolygon, Array{Vector{T}, 1}}} where T<:Integer","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.is_isomorphic","text":"is_isomorphic(g1::TriangulatedPolygon, g2::TriangulatedPolygon, permutations::Vector{Vector{T}}) where T<:Integer\n\nCheck if g2 is isomorphic to g1 up to a relabeling of the vertices by one of the permutations.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"The following methods are used to build the flip graph; However, they can also be useful elsewhere:","category":"page"},{"location":"flipGraphPlanar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"    mcKay\n    rename_vertices(::TriangulatedPolygon, ::Vector{<:Integer})\n    rename_vertices!(::TriangulatedPolygon, ::Vector{<:Integer})    ","category":"page"},{"location":"flipGraphPlanar/#FlipGraphs.mcKay","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.mcKay","text":"mcKay(g::TriangulatedPolygon) :: Vector{Vector{<:Integer}}\n\nApply McKay's canonical graph labeling algorithm to determine all possible permutations  of the vertices, which give a canonical isomorphism class representant.\n\nReturn a list of all possible canonical point-relabeling permutations p such that the i-th point should be relabeled as the p[i]-th point\n\n\n\n\n\n","category":"function"},{"location":"flipGraphPlanar/#FlipGraphs.rename_vertices-Tuple{TriangulatedPolygon, Vector{var\"#s4\"} where var\"#s4\"<:Integer}","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.rename_vertices","text":"rename_vertices(g::TriangulatedPolygon, p::Vector{<:Integer}) :: TriangulatedPolygon\n\nReturn the TriangulatedPolygon obtained from renaming the vertices of the triangulated convex polygon g by applying the permutation p.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/#FlipGraphs.rename_vertices!-Tuple{TriangulatedPolygon, Vector{var\"#s4\"} where var\"#s4\"<:Integer}","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.rename_vertices!","text":"rename_vertices!(g::TriangulatedPolygon, p::Vector{<:Integer}) :: TriangulatedPolygon\n\nRename the vertices of the triangulated convex polygon g by applying the permutation p.\n\n\n\n\n\n","category":"method"},{"location":"flipGraphPlanar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"[1]: Hartke, S.G., & Radcliffe, A.J. (2008). McKay ’ s Canonical Graph Labeling Algorithm.","category":"page"},{"location":"generalUtilities/#General-utilities","page":"General utilities","title":"General utilities","text":"","category":"section"},{"location":"generalUtilities/","page":"General utilities","title":"General utilities","text":"These are some methods that you might want to use, but they aren't specific to one of the main structures in this package.","category":"page"},{"location":"generalUtilities/","page":"General utilities","title":"General utilities","text":"diameter(::Matrix{T}) where T<:Integer\ndistances\nadjacency_matrix(::Vector{Vector{T}}) where T<:Integer\nmatrix_equal\ninvert_permutation\ndegrees\nrelative_degree\nrelative_degrees(::Matrix{T}, ::Vector{<:Integer}, ::Vector{<:Integer}) where T<:Integer","category":"page"},{"location":"generalUtilities/#FlipGraphs.diameter-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Integer","page":"General utilities","title":"FlipGraphs.diameter","text":"diameter(adjacency_matrix :: Matrix{<:Integer}) :: Int\n\nCompute the diameter of a graph from its simple adjacency matrix.\n\nAll values in adjacency_matrix should be either 0 or 1.\n\n\n\n\n\n","category":"method"},{"location":"generalUtilities/#FlipGraphs.distances","page":"General utilities","title":"FlipGraphs.distances","text":"distances(adjacency_matrix :: Matrix{T}) :: Matrix{T} where T<:Integer\n\nCompute the shortest distance from any vertex to any other vertex in the graph for the given adjacency_matrix.\n\nReturn a Matrix whose entry at (i,j) is the length of a shortest path from i to j.\n\nThe Graph has to be connected. This method uses Seidels APSP-Algorithm.\n\n\n\n\n\n","category":"function"},{"location":"generalUtilities/#FlipGraphs.adjacency_matrix-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T<:Integer","page":"General utilities","title":"FlipGraphs.adjacency_matrix","text":"adjacency_matrix(adjList::Vector{Vector{<:Integer}}) :: Matrix{Int}\n\nConstruct the adjacency matrix from an adjacency list.\n\n\n\n\n\n","category":"method"},{"location":"generalUtilities/#FlipGraphs.matrix_equal","page":"General utilities","title":"FlipGraphs.matrix_equal","text":"matrix_equal(A::Matrix{Int}, B::Matrix{Int}, p::Vector{Int}) :: Bool\n\nreturns true if A == B[p,p]`\n\n\n\n\n\nmatrix_equal(A::Matrix{Int}, B::Matrix{Int}) :: Bool\n\nReturn true if A equals B. \n\nThis function is much faster than calling A==B. However, A and B are assumed to have the same dimensions.\n\n\n\n\n\n","category":"function"},{"location":"generalUtilities/#FlipGraphs.invert_permutation","page":"General utilities","title":"FlipGraphs.invert_permutation","text":"invert_permutation(p::Vector{<:Integer})\n\nReturn the inverse of the permutation p. \n\nExample\n\njulia> p = [2,1,4,5,3];\njulia> p_inv = invert_perm(p); \njulia> show(p_inv)\n[4, 2, 5, 1, 6, 3]\njulia> show(p_inv[p])\n[1, 2, 3, 4, 5, 6]\n\n\n\n\n\n","category":"function"},{"location":"generalUtilities/#FlipGraphs.degrees","page":"General utilities","title":"FlipGraphs.degrees","text":"degrees(A::Matrix{<:Integer}) :: Vector{<:Integer}\n\nReturn a vector containing the degrees of every vertex given an adjacency matrix A.\n\n\n\n\n\ndegrees(g::TriangulatedPolygon) :: Vector{Int32}\n\nCompute a list of the degrees of every single vertex in g.\n\n\n\n\n\n","category":"function"},{"location":"generalUtilities/#FlipGraphs.relative_degree","page":"General utilities","title":"FlipGraphs.relative_degree","text":"relative_degree(A::Matrix{<:Integer}, u::Integer, V::Vector{<:Integer}) :: Int32\n\nCompute the number of edges going from u into any vertex in the subset of points V.\n\nArguments\n\n-A::Matrix{<:Integer}: the adjacency matrix. A[i,j] = 1 if there is an edge going from i to j\n\n\n\n\n\nrelative_degree(g::TriangulatedPolygon, u::Integer, V::Vector{<:Integer}) :: Vector{<:Integer}\n\nCount the number of edges in g going from u to a vertex in V.\n\n\n\n\n\n","category":"function"},{"location":"generalUtilities/#FlipGraphs.relative_degrees-Union{Tuple{T}, Tuple{Matrix{T}, Vector{var\"#s4\"} where var\"#s4\"<:Integer, Vector{var\"#s5\"} where var\"#s5\"<:Integer}} where T<:Integer","page":"General utilities","title":"FlipGraphs.relative_degrees","text":"relative_degrees(A::Matrix{<:Integer}, U::Vector{<:Integer}, V::Vector{<:Integer}) :: Vector{Int32}\n\nCompute the relative degrees of points in U onto the subset of points V.\n\n\n\n\n\n","category":"method"},{"location":"#FlipGraphs.jl-Documentation","page":"FlipGraphs.jl Documentation","title":"FlipGraphs.jl Documentation","text":"","category":"section"},{"location":"","page":"FlipGraphs.jl Documentation","title":"FlipGraphs.jl Documentation","text":"Welcome to the documentation of the FlipGraphs.jl package.  This package was created as part of my master's thesis on triangulations of closed surfaces and the flip graphs thereof.","category":"page"},{"location":"","page":"FlipGraphs.jl Documentation","title":"FlipGraphs.jl Documentation","text":"The aim of the package is to model triangulations on any closed surface and  compute their respective flip graphs.","category":"page"},{"location":"","page":"FlipGraphs.jl Documentation","title":"FlipGraphs.jl Documentation","text":"    FlipGraphs","category":"page"},{"location":"#FlipGraphs","page":"FlipGraphs.jl Documentation","title":"FlipGraphs","text":"FlipGraphs\n\nA package for triangulations of points and their respective flip graphs.\n\nSo far, this package includes:\n- triangulations of convex polygons / triangulations of points situated on the border of a disc and their flip graphs (with labeled and unlabeled points).\n- triangulations of points on a closed surface and their respective modular flip graphs (with labeled and unlabeled points).\n\n\n\n\n\n","category":"module"},{"location":"#Table-of-contents","page":"FlipGraphs.jl Documentation","title":"Table of contents","text":"","category":"section"},{"location":"","page":"FlipGraphs.jl Documentation","title":"FlipGraphs.jl Documentation","text":"Pages = [\"install.md\", \"quickStart.md\", \"polygonTriangulation.md\", \"flipGraphPlanar\", \"deltaComplex.md\", \"flipGraph.md\", \"exporting.md\",\"generalUtilities.md\"]","category":"page"}]
}
